---
number: 038
title: Validation Tuple Implementation Tests
category: testing
priority: medium
status: draft
dependencies: []
created: 2025-11-27
---

# Specification 038: Validation Tuple Implementation Tests

**Category**: testing
**Priority**: medium
**Status**: draft
**Dependencies**: None

## Context

The `src/validation/core.rs` module implements the `ValidateAll` trait for tuples of 2 to 12 elements, allowing parallel validation with error accumulation. Current coverage is **28% (59/211 lines)**, with the gap entirely in tuple implementations for 4+ elements.

### Uncovered Lines (from tarpaulin)
```
src/validation/core.rs: 499-505, 524-532, 552-562, 583-595, 617-631, 654-670, 694-712, 737-757, 797-820
```

These correspond to the `ValidateAll` implementations generated by the `impl_validate_all_tuple!` macro for:
- 4-tuple (lines 499-505)
- 5-tuple (lines 524-532)
- 6-tuple (lines 552-562)
- 7-tuple (lines 583-595)
- 8-tuple (lines 617-631)
- 9-tuple (lines 654-670)
- 10-tuple (lines 694-712)
- 11-tuple (lines 737-757)
- 12-tuple (lines 797-820)

While 2-tuple and 3-tuple implementations have test coverage, larger tuples are untested. Since the macro generates similar code, the risk is lower, but comprehensive coverage ensures the implementations work correctly.

## Objective

Achieve test coverage for all `ValidateAll` tuple implementations (4+ elements), targeting 100% coverage of macro-generated code. Tests should validate:
1. All-success case produces correct tuple
2. All-failure case accumulates all errors
3. Mixed success/failure accumulates only errors
4. Correct tuple structure (no nesting artifacts)

## Requirements

### Functional Requirements

#### FR-1: 4-Tuple Validation Tests
- Test `(Success, Success, Success, Success)` → `Success((a, b, c, d))`
- Test `(Failure, Failure, Failure, Failure)` → `Failure(all errors combined)`
- Test mixed → only failures accumulated

#### FR-2: Larger Tuple Tests (5-12 elements)
- Each tuple size needs at least:
  - One all-success test
  - One all-failure test
- Output tuple must be flat (not nested pairs)

#### FR-3: Error Accumulation Verification
- Errors combine using `Semigroup::combine`
- Order of errors matches input order
- No duplicate or lost errors

### Non-Functional Requirements

#### NFR-1: Test Organization
- Group tests by tuple size for clarity
- Use descriptive test names indicating arity

#### NFR-2: Maintainability
- Consider using macro-generated tests to reduce boilerplate
- Keep test structure consistent across tuple sizes

## Acceptance Criteria

- [ ] 4-tuple: all-success test passes
- [ ] 4-tuple: all-failure test with error accumulation passes
- [ ] 5-tuple: all-success test passes
- [ ] 5-tuple: all-failure test passes
- [ ] 6-tuple: all-success test passes
- [ ] 6-tuple: all-failure test passes
- [ ] 7-tuple: all-success test passes
- [ ] 7-tuple: all-failure test passes
- [ ] 8-tuple: all-success test passes
- [ ] 8-tuple: all-failure test passes
- [ ] 9-tuple: at least one test passes
- [ ] 10-tuple: at least one test passes
- [ ] 11-tuple: at least one test passes
- [ ] 12-tuple: at least one test passes
- [ ] All tests verify flat tuple output (not nested)
- [ ] Line coverage for tuple impls exceeds 90%

## Technical Details

### Implementation Approach

Tests will be added to the existing `#[cfg(test)]` module in `src/validation/core.rs`.

### Test Structure

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // Existing 2-tuple and 3-tuple tests...

    // === 4-tuple tests ===

    #[test]
    fn test_validate_all_4tuple_all_success() {
        let result = (
            Validation::success(1),
            Validation::success("two"),
            Validation::success(3.0),
            Validation::success(true),
        ).validate_all();

        assert_eq!(result, Validation::Success((1, "two", 3.0, true)));
    }

    #[test]
    fn test_validate_all_4tuple_all_failure() {
        let result: Validation<(i32, i32, i32, i32), Vec<&str>> = (
            Validation::Failure(vec!["e1"]),
            Validation::Failure(vec!["e2"]),
            Validation::Failure(vec!["e3"]),
            Validation::Failure(vec!["e4"]),
        ).validate_all();

        assert_eq!(result, Validation::Failure(vec!["e1", "e2", "e3", "e4"]));
    }

    #[test]
    fn test_validate_all_4tuple_mixed() {
        let result: Validation<(i32, i32, i32, i32), Vec<&str>> = (
            Validation::Success(1),
            Validation::Failure(vec!["e2"]),
            Validation::Success(3),
            Validation::Failure(vec!["e4"]),
        ).validate_all();

        assert_eq!(result, Validation::Failure(vec!["e2", "e4"]));
    }

    // === 5-tuple tests ===

    #[test]
    fn test_validate_all_5tuple_all_success() {
        let result = (
            Validation::success(1),
            Validation::success(2),
            Validation::success(3),
            Validation::success(4),
            Validation::success(5),
        ).validate_all();

        assert_eq!(result, Validation::Success((1, 2, 3, 4, 5)));
    }

    #[test]
    fn test_validate_all_5tuple_all_failure() {
        let result: Validation<(i32, i32, i32, i32, i32), Vec<&str>> = (
            Validation::Failure(vec!["e1"]),
            Validation::Failure(vec!["e2"]),
            Validation::Failure(vec!["e3"]),
            Validation::Failure(vec!["e4"]),
            Validation::Failure(vec!["e5"]),
        ).validate_all();

        assert_eq!(result, Validation::Failure(vec!["e1", "e2", "e3", "e4", "e5"]));
    }

    // ... continue for 6-12 tuples

    // === Macro-based tests for larger tuples ===

    macro_rules! test_tuple_success {
        ($name:ident, $count:expr, $($val:expr),+) => {
            #[test]
            fn $name() {
                let result = (
                    $(Validation::success($val)),+
                ).validate_all();

                assert!(matches!(result, Validation::Success(_)));
            }
        };
    }

    test_tuple_success!(test_6tuple_success, 6, 1, 2, 3, 4, 5, 6);
    test_tuple_success!(test_7tuple_success, 7, 1, 2, 3, 4, 5, 6, 7);
    test_tuple_success!(test_8tuple_success, 8, 1, 2, 3, 4, 5, 6, 7, 8);
    test_tuple_success!(test_9tuple_success, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9);
    test_tuple_success!(test_10tuple_success, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    test_tuple_success!(test_11tuple_success, 11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11);
    test_tuple_success!(test_12tuple_success, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
}
```

### Key Test Scenarios

1. **All Success** - Verifies correct tuple construction
2. **All Failure** - Verifies all errors are accumulated
3. **Mixed** - Verifies only failure errors appear in result
4. **Type Heterogeneity** - Use different types to verify generics work

## Dependencies

- **Prerequisites**: None
- **Affected Components**: `src/validation/core.rs`
- **External Dependencies**: None

## Testing Strategy

- **Unit Tests**: Direct tests of `validate_all()` method
- **Property Tests**: Could use proptest for larger tuples (optional)
- **Edge Cases**: All same type vs heterogeneous types

## Documentation Requirements

- **Code Documentation**: Ensure macro-generated impls have clear docs
- **User Documentation**: No changes needed

## Implementation Notes

- Test macros can reduce boilerplate for 12 similar implementations
- Verify output is flat tuple, not nested pairs like `((((a, b), c), d), e)`
- Use `Vec<&str>` as error type for clear error accumulation verification
- Consider testing with different Semigroup types (String, NonEmptyVec)

## Migration and Compatibility

No migration needed - this is additive test coverage.
